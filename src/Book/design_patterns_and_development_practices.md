# 基础知识

1、面向对象的 JavaScript

1.1 动态类型语言和鸭子类型

1.2 多态

1.3 封装

1.4 原型模式和基于原型继承的 JavaScript 对象系统

2、this、call、apply

2.1 this

2.2 `call`和`apply`

3、闭包和高阶函数

3.1 闭包

3.2 高阶函数

3.3 小结

> 设计模式

4、单例模式

4.1 实现单例模式

4.2 透明的单例模式

4.3 用代理实现单例模式

4.4 JavaScript 中的单例模式

4.5 惰性单例

4.6 通用的惰性单例

4.7 小结

5、策略模式

5.1 使用策略模式计算奖金

5.2 JavaScript 版本的策略模式

5.3 多态在策略模式中的体现

5.4 使用策略模式实现缓动动画

5.5 更广义的“算法”

5.6 表单验证

5.7 策略模式的优缺点

5.8 一等函数对象的策略模式

5.9 小结

6、代理模式

6.1 第一个例子--小明追 MM 的故事

6.2 保护代理和虚拟代理

6.3 虚拟代理实现图片预加载

6.4 代理的意义

6.5 代理和本体接口的一致性

6.6 虚拟代理合并 HTTP 请求

6.7 虚拟代理在惰性加载中的应用

6.8 缓存代理

6.9 用高阶函数动态创建代理

6.10 其他代理模式

6.11 小结

7、迭代器模式

7.1 jQuery 中的迭代器

7.2 实现内部的迭代器

7.3 内部迭代器和外部迭代器

7.4 迭代类数组对象和字面量对象

7.5 倒叙迭代器

7.6 中止迭代器

7.7 迭代器模式的应用举例

7.8 小结

8、发布-订阅模式

8.1 现实中的发布-订阅模式

8.2 发布-订阅模式的作用

8.3 DOM 事件

8.4 自定义事件

8.5 发布-订阅模式的通用实现

8.6 取消订阅的事件

8.7 真实的例子--网站登录

8.8 全局的发布-订阅对象

8.9 模块间通信

8.10 必须先订阅再发布吗

8.11 全局事件的命名冲突

8.12 JavaScript 实现发布-订阅模式的便利性

8.13 小结

9、命令模式

9.1 命令模式的用途

9.2 命令模式的例子-菜单程序

9.3 JavaScript 的命令模式

9.4 撤销命令

9.5 撤销和重做

9.6 命令队列

9.7 宏命令

9.8 智能命令和傻瓜命令

9.9 小结

10、组合模式

10.1 回顾鸿命令

10.2 组合模式的用途

10.3 请求在树中的传递过程

10.4 更强大的宏命令

10.5 抽象类在组合模式中的作用

10.6 透明性带来的安全问题

10.7 组合模式的例子--扫描文件

10.8 一些值得注意的地方

10.9 引用父对象

10.10 何时使用组合模式

10.11 小结

11、模板方法模式

11.1 模板方法模板的定义和组成

11.2 第一个例子-- Coffee 和 Tea

11.3 抽象类

11.4 模板方法模式的使用场景

11.5 钩子方法

11.6 好莱坞原则

11.7 真的需要“继承”吗

11.8 小结

12、享元模式

12.1 初识享元模式

12.2 内部状态和外部状态

12.3 享元模式的通用结构

12.4 文件上传的例子

12.5 享元模式的适用性

12.6 再谈内部状态和外部状态

12.7 对象池

12.8 小结

13、职责链模式

13.1 现实中的职责链模式

13.2 实际开发中的职责链模式

13.3 用职责链模式重构代码

13.4 灵活可拆分的职责链节点

13.5 异步的职责链

13.6 职责链模式的优缺点

13.7 用 AOP 实现职责链

13.8 用职责链模式获取文件上传对象

13.9 小结

14、中介者模式

14.1 现实中的中介者

14.2 中介者模式的例子--泡泡堂游戏

14.3 中介者模式的例子--购买商品

14.4 小结

15、装饰者模式

15.1 模拟传统面向对象语言的装饰者模式

15.2 装饰者也是包装器

15.3 回到 JavaScript 的装饰者

15.4 装饰函数

15.5 用 AOP 装饰函数

15.6 AOP 的应用实例

15.7 装饰者模式和代理模式

15.8 小结

16、状态模式

16.1 初识状态模式

16.2 状态模式的定义

16.3 状态模式的通用结构

16.4 缺少抽象类的变通方式

16.5 另一个状态模式示例--文件上传

16.6 状态模式的优缺点

16.7 状态模式中的性能优化点

16.8 状态模式和策略模式的关系

16.9 JavaScript 版本的状态机

16.10 表驱动的有限状态机

16.11 实际项目中的其他状态机

16.12 小结

17、适配器模式

17.1 现实中的适配器

17.2 适配器模式的应用

17.3 小结

> 设计原则和编程技巧

18、单一职责原则

18.1 设计模式中的 SRP 原则

18.2 何时应该分离职责

18.3 违反 SRP 原则

18.4 SRP 原则的优缺点

19、最少知识原则

19.1 减少对象之间的联系

19.2 设计模式中 LKP 原则

19.3 封装在 LPK 原则中的体现

20、开放-封闭原则

20.1 拓展 window.onload 函数

20.2 开放和封闭

20.3 用对象的多态性消除条件分支

20.4 找出变化的地方

20.5 设计模式中的开放-封闭原则

20.6 开放-封闭原则的相对性

20.7 接受第一次愚弄

21、接口和面向接口编程

21.1 回到 Java 的抽象类

21.2 interface

21.3 `JavaScript`语言是否需要抽象类和`interface`

21.4 用鸭子类型进行接口检查

21.5 用`TypeScript`编写基于`interface`的命令模式

22、代码重构

22.1 提炼函数

22.2 合并重复的条件片段

22.3 把条件分支语句提炼成函数

22.4 合理使用循环

22.5 提前让函数退出替代嵌套条件分支

22.6 传递对象参数代替过长的参数列表

22.7 尽量减少参数数量

22.8 少用三目运算符

22.9 合理使用链式调用

22.10 分解大型类

22.11 用 return 退出多重循环
